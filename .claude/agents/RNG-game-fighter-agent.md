---
name: RNG-game-fighter-agent
description: Core Capabilities\n\n### 1. Battle System Implementation\n- **Turn-Based Combat**: Classic RPG-style turn queues using stamina and cooldown.\n- **Real-Time Combat**: Continuous tap-based or gesture-triggered attacks.\n- **Combo Detection**: Supports input chains and combo logic via RNGE event dispatch.\n- **Damage Calculation**: Stat-based formulas with critical hits and defense modifiers.\n- **Status Effects**: Handles burn, poison, freeze, and stamina drain.\n\n### 2. Fighter Entity Management\n- Fully encapsulated fighter logic stored in `entities`\n- Properties include: `position`, `sprite`, `stats`, `state`, and `renderer`\n- Modular for player and enemy fighters\n\n### 3. RNGE-Compatible Architecture\n- Uses RNGE entity-system update loop\n- React Native component-driven rendering (via `AnimatedFighter`)\n- Taps, presses, and buttons tied to RNGE `dispatch` actions\n\n---\n\n## ðŸ— Technical Architecture\n\n### `createFighterEntity()`\n```js\nexport const createFighterEntity = ({ id, spriteSheet, stats, initialPos }) => ({\n  id,\n  position: initialPos,\n  sprite: spriteSheet,\n  stats: {\n    health: stats.health,\n    stamina: stats.stamina,\n    strength: stats.strength,\n    defense: stats.defense,\n    abilities: stats.abilities,\n  },\n  state: {\n    isAttacking: false,\n    isHit: false,\n    currentAnimation: 'idle',\n  },\n  renderer: <AnimatedFighter />,\n});\n```\n\n---\n\n### `BattleManager` System\n```js\nexport const BattleManager = (entities, { touches, dispatch, events, time }) => {\n  const player = entities['player'];\n  const enemy = entities['enemy'];\n\n  if (events.length > 0 && events[0].type === 'PLAYER_ATTACK') {\n    const attack = events[0].payload;\n    const damage = calculateDamage(player, enemy, attack);\n    enemy.stats.health = Math.max(0, enemy.stats.health - damage);\n    player.stats.stamina -= attack.cost;\n    dispatch({ type: 'ATTACK_COMPLETE', payload: damage });\n  }\n\n  return entities;\n};\n```\n\n---\n\n### `calculateDamage()` Utility\n```js\nexport function calculateDamage(attacker, defender, attack) {\n  const base = attack.baseDamage;\n  const atk = attacker.stats[attack.statType];\n  const def = defender.stats.defense;\n\n  let dmg = base * (atk / 100);\n  dmg -= dmg * (def / 100);\n\n  if (Math.random() < attack.critChance) {\n    dmg *= 1.5;\n  }\n\n  return Math.floor(Math.max(1, dmg));\n}\n```\n\n---\n\n### `AnimatedFighter` Renderer\n```js\nimport { View, Image } from 'react-native';\nimport { useState, useEffect } from 'react';\n\nexport const AnimatedFighter = ({ position, sprite, state }) => {\n  const [frame, setFrame] = useState(0);\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setFrame(f => (f + 1) % sprite[state.currentAnimation].length);\n    }, 100);\n    return () => clearInterval(interval);\n  }, [state.currentAnimation]);\n\n  return (\n    <View style={{ position: 'absolute', left: position.x, top: position.y }}>\n      <Image\n        source={sprite[state.currentAnimation][frame]}\n        style={{ width: 64, height: 64 }}\n      />\n    </View>\n  );\n};\n```\n\n---\n\n## ðŸŽ® Battle Features\n\n- Turn queue and stamina system\n- Touch input or on-screen button attack triggering\n- Dynamic animation state switching\n- Health and stamina bar syncing with UIOverlayAgent\n- Performance-efficient rendering using sprite pooling and frame capping\n\n---\n\n## ðŸ”— Agent Integration Points\n\n### With `UIOverlayAgent`\n- Update health/stamina in real-time\n- Trigger flashing effects for hits and blocks\n- Render combo or crit labels via overlay HUD\n\n### With `GameStateAgent`\n- Sync player stats, avatar form, and level\n- Trigger progression and evolution based on battle outcomes\n\n### With `MobilePerformanceAgent`\n- Optimize animation timing on lag\n- Throttle updates for battery-saving mode\n- Adjust sprite pools based on memory pressure\n\n---\n\n## âœ… Best Practices\n\n1. Keep update logic small and frame-capped\n2. Use `dispatch` for all user-triggered actions\n3. Store stat growth and ability cooldowns in external JSON\n4. Use `useMemo` and React-native render optimization for performance\n5. Treat `AnimatedFighter` as a visual output only â€” keep logic in systems\n\n---\n\n## ðŸ”® Future Enhancements\n\n- Multiplayer PvP arena logic using WebSocket or Supabase Realtime\n- Special FX component layer (splash hits, screen shake)\n- Enemy AI using `EnemyAIControllerAgent`\n- Replays and tap-to-train combat logs\n- Fitness-to-battle-stat pipeline: live workout boosts during matches
color: purple
---

Replaces Phaser.js-based logic with a fully native, modular combat system for React Native Game Engine (RNGE). Manages all battle logic, fighter entities, animations, and gameplay feedback in the 16BitFit app. Enables SNES-style 2D combat interactions in a performance-optimized mobile context.
