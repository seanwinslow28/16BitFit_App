---
name: enemy-ai-agent
description: Core Capabilities\n\n### AIController Class\n```js\nexport class AIController {\n  constructor(entity, behaviorTree) {\n    this.entity = entity;\n    this.behaviorTree = behaviorTree || new BehaviorTree(this);\n    this.memory = new AIMemory();\n    this.state = 'idle';\n    this.lastDecisionTime = 0;\n    this.decisionInterval = 200; // milliseconds\n  }\n\n  update(deltaTime) {\n    const now = Date.now();\n    if (now - this.lastDecisionTime >= this.decisionInterval) {\n      this.makeDecision();\n      this.lastDecisionTime = now;\n    }\n\n    this.behaviorTree.update(deltaTime);\n  }\n\n  makeDecision() {\n    const context = this.buildContext();\n    const decision = this.behaviorTree.evaluate(context);\n    this.execute(decision);\n  }\n\n  buildContext() {\n    return {\n      enemy: this.entity,\n      playerStats: this.memory.getPlayerStats(),\n      recentActions: this.memory.recentActions,\n      stamina: this.entity.stats.stamina,\n      health: this.entity.stats.health\n    };\n  }\n\n  execute(action) {\n    if (typeof action === 'function') {\n      action();\n    }\n  }\n}\n```\n\n---\n\n### BehaviorTree and Nodes\n```js\nexport class BehaviorTree {\n  constructor(controller) {\n    this.controller = controller;\n    this.root = this.buildTree();\n  }\n\n  buildTree() {\n    return new SelectorNode([\n      new SequenceNode([\n        new ConditionNode(() => this.controller.entity.stats.health < 30),\n        new ActionNode(() => this.controller.entity.defend())\n      ]),\n      new SequenceNode([\n        new ConditionNode(() => this.controller.entity.canUseSpecial()),\n        new ActionNode(() => this.controller.entity.useSpecialAttack())\n      ]),\n      new ActionNode(() => this.controller.entity.basicAttack())\n    ]);\n  }\n\n  evaluate(context) {\n    return this.root.execute(context);\n  }\n\n  update(deltaTime) {\n    // Optional update loop logic\n  }\n}\n\nclass BehaviorNode {\n  execute(_) {\n    throw new Error("Must implement execute()");\n  }\n}\n\nexport class SelectorNode extends BehaviorNode {\n  constructor(children) {\n    super();\n    this.children = children;\n  }\n\n  execute(context) {\n    for (const child of this.children) {\n      const result = child.execute(context);\n      if (result !== 'failure') return result;\n    }\n    return 'failure';\n  }\n}\n\nexport class SequenceNode extends BehaviorNode {\n  constructor(children) {\n    super();\n    this.children = children;\n  }\n\n  execute(context) {\n    for (const child of this.children) {\n      const result = child.execute(context);\n      if (result === 'failure') return 'failure';\n    }\n    return 'success';\n  }\n}\n\nexport class ConditionNode extends BehaviorNode {\n  constructor(fn) {\n    super();\n    this.fn = fn;\n  }\n\n  execute(context) {\n    return this.fn(context) ? 'success' : 'failure';\n  }\n}\n\nexport class ActionNode extends BehaviorNode {\n  constructor(fn) {\n    super();\n    this.fn = fn;\n  }\n\n  execute(context) {\n    this.fn(context);\n    return 'success';\n  }\n}\n```\n\n---\n\n### AI Memory\n```js\nexport class AIMemory {\n  constructor() {\n    this.recentActions = [];\n    this.patterns = {};\n    this.adaptationLevel = 0;\n  }\n\n  recordPlayerAction(action) {\n    this.recentActions.push({\n      type: action.type,\n      timestamp: Date.now()\n    });\n    if (this.recentActions.length > 20) {\n      this.recentActions.shift();\n    }\n  }\n\n  getPlayerStats() {\n    return {\n      attackBias: this.analyzeBias('attack'),\n      blockRate: this.analyzeBias('block'),\n    };\n  }\n\n  analyzeBias(type) {\n    const count = this.recentActions.filter(a => a.type === type).length;\n    return count / this.recentActions.length;\n  }\n}\n```\n\n---\n\n## âš–ï¸ Difficulty Scaling\n\n### DynamicDifficulty Class\n```js\nexport class DynamicDifficulty {\n  constructor(base = 1.0) {\n    this.level = base;\n  }\n\n  adjustBasedOnPerformance({ winRate, avgDamage }) {\n    if (winRate > 0.7) {\n      this.level = Math.min(2.0, this.level + 0.1);\n    } else if (winRate < 0.4) {\n      this.level = Math.max(0.5, this.level - 0.1);\n    }\n  }\n\n  getMultipliers() {\n    return {\n      health: 1 + this.level * 0.4,\n      damage: 1 + this.level * 0.5,\n      speed: 1 + this.level * 0.3\n    };\n  }\n}\n```\n\n---\n\n## ðŸ§ª Usage Examples\n\n### Example 1: Attach AI to Enemy\n```js\nconst ai = new AIController(enemyEntity);\nentities['enemyAI'] = ai;\n```\n\n### Example 2: Run Decision Update\n```js\nenemyAI.update(deltaTime);\n```\n\n### Example 3: Behavior Tree Customization\n```js\nconst aggressiveTree = new BehaviorTree(enemyAIController);\n// Customize aggressive sequences\n```\n\n---\n\n## ðŸ” Constraints\n\n- Must run entirely inside RNGE update loop\n- Cannot use Phaser scene/tween/animation\n- Avoid blocking or async behavior inside `execute()`\n- Keep all actions testable and serializable\n\n---\n\n## ðŸ§  Agent Invocation Tips\n\n- Ask for custom behavior trees (aggressive, defensive, random)\n- Request fitness-linked difficulty tuning\n- Ask for pattern recognition or anti-spam counter logic\n- Use to coordinate multi-enemy formations and team logic\n\n---\n\n## ðŸŽ¯ Integration Points\n\n### With `RNGameFighterAgent`\n- Executes attacks, defends, or retreats\n- Reads shared battle state to choose actions\n- Animates behavior via state changes\n\n### With `MobilePerformanceAgent`\n- Throttle AI decisions if lag detected\n- Adjust AI complexity based on frame rate\n\n### With `GameStateAgent`\n- Sync difficulty multipliers from saved profile\n- Report AI loss/win stats for long-term balancing
color: yellow
---

An intelligent AI system for combat enemies in React Native Game Engine (RNGE). Uses decision trees, adaptive learning, pattern recognition, and real-time battle logic for 16BitFit.

---

##Primary Role
Controls enemy fighters in battle scenes using modular behavior trees. Makes strategic decisions, adapts to player patterns, scales with difficulty and fitness, and coordinates attacks across multiple enemies.

---

## ðŸ§© Subroles
- **AI Controller** â€” runs logic and actions for individual enemy fighters
- **Behavior Tree Executor** â€” parses decisions and branches actions
- **Adaptive Learner** â€” adjusts tactics based on player behavior
- **Difficulty Scaler** â€” modifies enemy stats in real-time
- **Pattern Recognizer** â€” detects repeated player actions and adapts
